<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>假期计划</title>
    <link href="/2024/12/31/%E5%81%87%E6%9C%9F%E8%AE%A1%E5%88%92/"/>
    <url>/2024/12/31/%E5%81%87%E6%9C%9F%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h1id="假期每日计划表2025年1月1号---2025年3月1号">假期每日计划表（2025年1月1号- 2025年3月1号）</h1><h2 id="每日计划">每日计划</h2><ul><li><strong>英语</strong>：1小时背单词 + 1小时阅读外刊</li><li><strong>数学</strong>：3小时高数</li><li><strong>专业课</strong>：3小时（计算机组成原理/计算机网络/计算机操作系统/数据结构）</li><li><strong>蓝桥杯准备</strong>：1小时算法训练</li><li><strong>其他</strong>：1小时Diango学习</li></ul><h2 id="每周计划">每周计划</h2><ul><li><strong>周一到周五</strong>：按照每日计划进行</li><li><strong>周六</strong>：复习本周内容，总结笔记，做模拟题</li><li><strong>周日</strong>：休息或自由安排，调整状态</li></ul><h2 id="具体安排">具体安排</h2><h3 id="年1月1日---2025年1月7日">2025年1月1日 - 2025年1月7日</h3><ul><li><strong>英语</strong>：背500个单词，阅读5篇外刊文章</li><li><strong>数学</strong>：完成高数第1-2讲</li><li><strong>专业课</strong>：完成计算机组成原理第一章</li><li><strong>蓝桥杯准备</strong>：完成5道算法题</li><li><strong>Diango学习</strong>：完成入门部分</li></ul><h3 id="年1月8日---2025年1月14日">2025年1月8日 - 2025年1月14日</h3><ul><li><strong>英语</strong>：背500个单词，阅读5篇外刊文章</li><li><strong>数学</strong>：完成高数第3-4讲</li><li><strong>专业课</strong>：完成计算机网络第一章</li><li><strong>蓝桥杯准备</strong>：完成5道算法题</li><li><strong>Diango学习</strong>：完成基础部分</li></ul><h3 id="年1月15日---2025年1月21日">2025年1月15日 - 2025年1月21日</h3><ul><li><strong>英语</strong>：背500个单词，阅读5篇外刊文章</li><li><strong>数学</strong>：完成高数第5-6讲</li><li><strong>专业课</strong>：完成计算机操作系统第一章</li><li><strong>蓝桥杯准备</strong>：完成5道算法题</li><li><strong>Diango学习</strong>：完成进阶部分</li></ul><h3 id="年1月22日---2025年1月28日">2025年1月22日 - 2025年1月28日</h3><ul><li><strong>英语</strong>：背500个单词，阅读5篇外刊文章</li><li><strong>数学</strong>：完成高数第7-8讲</li><li><strong>专业课</strong>：完成数据结构第一章</li><li><strong>蓝桥杯准备</strong>：完成5道算法题</li><li><strong>Diango学习</strong>：完成项目部分</li></ul><h3 id="年1月29日---2025年2月4日">2025年1月29日 - 2025年2月4日</h3><ul><li><strong>英语</strong>：背500个单词，阅读5篇外刊文章</li><li><strong>数学</strong>：完成高数第9-10讲</li><li><strong>专业课</strong>：完成计算机组成原理第二章</li><li><strong>蓝桥杯准备</strong>：完成5道算法题</li><li><strong>Diango学习</strong>：复习前四章内容</li></ul><h3 id="年2月5日---2025年2月11日">2025年2月5日 - 2025年2月11日</h3><ul><li><strong>英语</strong>：背500个单词，阅读5篇外刊文章</li><li><strong>数学</strong>：完成高数第11-12讲</li><li><strong>专业课</strong>：完成计算机网络第二章</li><li><strong>蓝桥杯准备</strong>：完成5道算法题</li><li><strong>Diango学习</strong>：完成高级部分</li></ul><h3 id="年2月12日---2025年2月18日">2025年2月12日 - 2025年2月18日</h3><ul><li><strong>英语</strong>：背500个单词，阅读5篇外刊文章</li><li><strong>数学</strong>：完成高数第13-14讲</li><li><strong>专业课</strong>：完成计算机操作系统第二章</li><li><strong>蓝桥杯准备</strong>：完成5道算法题</li><li><strong>Diango学习</strong>：完成项目部分</li></ul><h3 id="年2月19日---2025年2月25日">2025年2月19日 - 2025年2月25日</h3><ul><li><strong>英语</strong>：背500个单词，阅读5篇外刊文章</li><li><strong>数学</strong>：完成高数第15-16讲</li><li><strong>专业课</strong>：完成数据结构第二章</li><li><strong>蓝桥杯准备</strong>：完成5道算法题</li><li><strong>Diango学习</strong>：完成高级部分</li></ul><h3 id="年2月26日---2025年3月1日">2025年2月26日 - 2025年3月1日</h3><ul><li><strong>英语</strong>：背500个单词，阅读5篇外刊文章</li><li><strong>数学</strong>：完成高数第17-18讲</li><li><strong>专业课</strong>：复习前八章内容</li><li><strong>蓝桥杯准备</strong>：完成5道算法题</li><li><strong>Diango学习</strong>：复习前八章内容</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>考研</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++常用STL</title>
    <link href="/2024/11/24/c-%E5%B8%B8%E7%94%A8STL/"/>
    <url>/2024/11/24/c-%E5%B8%B8%E7%94%A8STL/</url>
    
    <content type="html"><![CDATA[<h1 id="stl">STL</h1><h2 id="vector-变长数组倍增的思想">vector, 变长数组，倍增的思想</h2><pre><code class="hljs">size()  返回元素个数empty()  返回是否为空clear()  清空front()/back()push_back()/pop_back()begin()/end()[] 支持随机寻址支持比较运算，按字典序</code></pre><h2 id="pairint-int存储二元组前后两类型任意">pair&lt;int,int&gt;存储二元组，前后两类型任意</h2><pre><code class="hljs">支持pair&lt;int,pair&lt;int,int&gt;&gt;;构造pair:make_pair(10,&quot;fireworks&quot;);first, 第一个元素second, 第二个元素支持比较运算，以first为第一关键字，以second为第二关键字（字典序）</code></pre><h2 id="string字符串">string，字符串</h2><pre><code class="hljs">可以用+连接size()/length()  返回字符串长度empty() 是否为空clear() 清空substr(起始下标，(子串长度))  返回子串，字串长度过长，输出到最后一个字母为止c_str()  返回字符串所在字符数组的起始地址</code></pre><h2 id="queue-队列">queue, 队列</h2><pre><code class="hljs">size()empty()push()  向队尾插入一个元素front()  返回队头元素back()  返回队尾元素pop()  弹出队头元素</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">100010</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-number">4</span>);<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-number">3</span>);<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,q.<span class="hljs-built_in">front</span>());<br>q.<span class="hljs-built_in">pop</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="priority_queue-优先队列默认是大根堆">priority_queue,优先队列，默认是大根堆</h2><pre><code class="hljs">size()empty()push()  插入一个元素top()  返回堆顶元素pop()  弹出堆顶元素定义成小根堆的方式：priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;</code></pre><h2 id="stack-栈">stack, 栈</h2><pre><code class="hljs">size()empty()push()  向栈顶插入一个元素top()  返回栈顶元素pop()  弹出栈顶元素</code></pre><h2 id="deque-双端队列">deque, 双端队列</h2><pre><code class="hljs">size()empty()clear()front()/back()push_back()/pop_back()push_front()/pop_front()begin()/end()[]</code></pre><h2id="set-map-multiset-multimap-基于平衡二叉树红黑树动态维护有序序列">set,map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列</h2><pre><code class="hljs">size()empty()clear()begin()/end()++, -- 返回前驱和后继，时间复杂度 O(logn)set/multiset    insert()  插入一个数    find()  查找一个数    count()  返回某一个数的个数    erase()        (1) 输入是一个数x，删除所有x   O(k + logn)        (2) 输入一个迭代器，删除这个迭代器    lower_bound()/upper_bound()        lower_bound(x)  返回大于等于x的最小的数的迭代器        upper_bound(x)  返回大于x的最小的数的迭代器map/multimap    insert()  插入的数是一个pair    erase()  输入的参数是pair或者迭代器    find()    []  注意multimap不支持此操作。 时间复杂度是 O(logn)    lower_bound()/upper_bound()</code></pre><h2id="unordered_set-unordered_map-unordered_multiset-unordered_multimap-哈希表">unordered_set,unordered_map, unordered_multiset, unordered_multimap, 哈希表</h2><pre><code class="hljs">和上面类似，增删改查的时间复杂度是 O(1)不支持 lower_bound()/upper_bound()， 迭代器的++，--</code></pre><h2 id="bitset-圧位">bitset, 圧位</h2><pre><code class="hljs">bitset&lt;10000&gt; s;~, &amp;, |, ^&gt;&gt;, &lt;&lt;==, !=[]count()  返回有多少个1any()  判断是否至少有一个1none()  判断是否全为0set()  把所有位置成1set(k, v)  将第k位变成vreset()  把所有位变成0flip()  等价于~flip(k) 把第k位取反</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础算法，c++语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>考研数学</title>
    <link href="/2024/09/25/%E6%95%B0%E5%AD%A6/"/>
    <url>/2024/09/25/%E6%95%B0%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<ul><li>xlnx当x→0时，lnx比x变化快，为什么结果是0(x的极限)而不是负无穷(lnx的极限)?</li></ul><figure><img src="https://bu.dusays.com/2024/09/25/66f3c272f2f57.png"alt="v2-87bd55a2cecb3b8ae0d4227adb3ab301_r.png" /><figcaptionaria-hidden="true">v2-87bd55a2cecb3b8ae0d4227adb3ab301_r.png</figcaption></figure><p>你只看到了lnx趋向无穷的速度，但是你小看了x趋向于0的速度。</p><p>lnx向着无穷的速度很快，但是快不快是相对的，你的目标也很遥远，要达到无穷</p><p>x趋向于一个确定的数，看似变化率慢，但是目标就在眼前。</p><p>也可以使用洛必达法则证得x趋于0+时 xlnx趋于0</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数值计算方法</title>
    <link href="/2024/08/17/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/"/>
    <url>/2024/08/17/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="计算方法">计算方法</h1><h2 id="绝对误差相对误差与有效数字">绝对误差，相对误差，与有效数字</h2><h3 id="绝对误差与相对误差">绝对误差与相对误差</h3><ul><li><p>若 <span class="math inline">\(x^{*}\)</span> 为 <spanclass="math inline">\(x\)</span> 的一个近似值，则称 <spanclass="math inline">\(x-x^{*}\)</span>为进似值<spanclass="math inline">\(x^{x}\)</span> 的绝对误差，用 <spanclass="math inline">\(e^{x}(x)\)</span> 表示</p></li><li><p>绝对误差限<span class="math inline">\(ε = x -a\)</span>可以清楚地表明近似值与准确值之间的差异</p></li><li><p>相对误差 $e_{x}(x)= = $</p></li></ul><h3 id="有效数字的计算"><strong>有效数字的计算</strong></h3><p>若近似值<spanclass="math inline">\(x^{*}\)</span>的某位数的<strong>半个单位</strong>是他的<strong>误差限</strong>，而且从<strong>该位</strong>数字到<spanclass="math inline">\(x^{*}\)</span>最左边的非零数字共有N位，则这N位数字称为有效数字</p><ul><li><p>半个单位的含义：以刻度尺为例子，它的最小刻度是1mm，度数我们只能确认到测量实际有没有过或者达到一个单位的一半，比如我们度数为15mm，那么其实际尺寸最小为14.5mm，最大尺寸为15.5mm，即最大误差不超过0.5mm，就是1mm的<strong>半个单位</strong>。如果以四舍五入为例的话，一个数字是14.56是保留两位有效数字的结果，那么真实数字肯定大于等于14.555小于14.565的，其误差最大为0.005，即其是0.01这个单位的一半。</p></li><li><p>计算位数时，是从<strong>该位</strong>数字到<spanclass="math inline">\(x^{*}\)</span>最左边的非零数字，注意包括该位数字</p></li></ul><h2 id="非线性方程求根">非线性方程求根</h2><h3 id="非线性方程的解与二分法">非线性方程的解与二分法</h3><p>问题形象：f()=0</p><ul><li>如<span class="math inline">\(sinx\)</span>=0</li></ul><p>其中<span class="math inline">\(f(x)\)</span>是一元函数，且<spanclass="math inline">\(f(x)\in C[a,b]\)</span>问题等价于求函数<spanclass="math inline">\(f(x)\)</span>的零点</p><p><strong>重根</strong>：若<spanclass="math inline">\(f(x)=\left(x-x^{*}\right)^{m} g(x),g\left(x^{*}\right) \neq 0\)</span> 则<spanclass="math inline">\(x^{*}\)</span>是<spanclass="math inline">\(f(x)=0\)</span>的m重根。</p><ul><li>如<span class="math inline">\((x-1)^{2}\)</span>,有重根</li></ul><p><strong>零点定理</strong>：设函数 <spanclass="math inline">\(f(x)\)</span>在闭区间[a,b]，且<spanclass="math inline">\(f(a).f(b)&lt;0\)</span>,则在开区间(a,b)内至少有一点<span class="math inline">\(\xi\)</span>,使<spanclass="math inline">\(f(\xi)=0.\)</span></p><ul><li>零点定理是二分法的基础</li><li>二分法解决问题的前提是：存在异号区间</li></ul><p>当异号区间足够小，就可以获得足够精度的近似解。</p><h4 id="二分法">二分法</h4><ul><li>思想与二分搜素中的<em>实数二分</em>十分相似</li></ul><p>二分法：（前提是有异号区间，思想是不断缩小异号区间） 步骤1计算异号区间 [a, b] 端点处的函数值 $f(a), f(b) $ ； (1) $x_{k+1}=x_{k}^{2}+x_{k}-3 $</p><p>步骤2 计算异号区间 [a, b] 中点处的函数值 <spanclass="math inline">\(f\left(\frac{a+b}{2}\right)\)</span> ；</p><p>步㵵3 若 $f()=0 $，则 $x= $是根，计算结束；</p><p>否则缩小区间: 若 $ f() f(a)&lt;0 $ ，赋值 $ b= ， f(b)=f() $ ；</p><p>若 $ f() f(b)&lt;0 $ ，赋值 $ a= ，$ $ f(a)=f() $</p><p>转步骤2</p><h3 id="迭代法">迭代法</h3><h2 id="拉格朗日插值多项式">拉格朗日插值多项式</h2><h3 id="拉格朗日插值基函数">拉格朗日插值基函数</h3><p>根据表中数据，构造拉格朗日插值基函数</p><table><thead><tr><th>xi</th><th style="text-align: center;">1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>yi</td><td style="text-align: center;">1</td><td>0</td><td>0</td></tr></tbody></table><em>利用待定系数法</em> <em>有几个节点，就有几个插值基函数</em> $<span class="math display">\[\begin{array}{c}l_{0}(x)=A(x-2)(x-3) \\l_{0}(1)=A(-1)(-2)=1 \\A=\frac{1}{2}\end{array}\]</span><p>$ 得 <span class="math display">\[l_{0}(x)=\frac{1}{2}(x-2)(x-3)\]</span></p><table><thead><tr><th>xi</th><th style="text-align: center;">1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>yi</td><td style="text-align: center;">0</td><td>1</td><td>0</td></tr></tbody></table>$<span class="math display">\[\begin{array}{c}l_{0}(x)=A(x-1)(x-3) \\l_{0}(1)=A(1)(-1)=-1 \\A=-1\end{array}\]</span><p>$ 得 <span class="math display">\[l_{1}(x)=-(x-1)(x-3)\]</span></p><table><thead><tr><th>xi</th><th style="text-align: center;">1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>yi</td><td style="text-align: center;">0</td><td>0</td><td>1</td></tr></tbody></table>$<span class="math display">\[\begin{array}{c}l_{0}(x)=A(x-1)(x-2) \\l_{0}(1)=A(2)(1)=1 \\A=\frac{1}{2}\end{array}\]</span><p>$ 得 <span class="math display">\[l_{0}(x)=\frac{1}{2}(x-1)(x-2)\]</span> ### 拉格朗日插值多项式</p><table><thead><tr><th>xi</th><th style="text-align: center;">1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>yi</td><td style="text-align: center;">5</td><td>9</td><td>6</td></tr></tbody></table><p><span class="math inline">\(\begin{array}{l}P(x)=5 {l_{0}(x)}+9 l_{1}(x)+6 l_{2}(x) \\P(x)=5 {l_{0}(1)}(=5)+9 l_{1}(1)(=0)+6 l_{2}(1)(=0)=5 \\\end{array}\)</span></p><h2 id="牛顿均差与牛顿插值多项式构造">牛顿均差与牛顿插值多项式构造</h2><h2 id="牛顿均差与均差表">牛顿均差与均差表</h2><p><span class="math inline">\(\begin{array}{l}一阶均差：f\left[x_{0},x_{1}\right]=\frac{f\left(x_{1}\right)-f\left(x_{0}\right)}{x_{1}-x_{0}}\\二阶均差：f\left[x_{0}, x_{1}, x_{2}\right]=\frac{f\left[x_{1},x_{2}\right]-f\left[x_{0}, x_{1}\right]}{x_{2}-x_{0}}\end{array}\)</span></p><ul><li>一阶均差可以看作是图像上两点连线的斜率</li><li>可以使用均差表计算均差</li></ul><table><thead><tr><th>xi</th><th style="text-align: center;">yi</th><th>一阶均差</th><th>二阶均差</th></tr></thead><tbody><tr><td>1</td><td style="text-align: center;"><spanclass="math inline">\(f(1)=5\)</span></td><td></td><td></td></tr><tr><td>2</td><td style="text-align: center;"><spanclass="math inline">\(f(2)=9\)</span></td><td><span class="math inline">\(f[1,2]=\frac{9-5}{2-1}=4\)</span></td><td></td></tr><tr><td>3</td><td style="text-align: center;"><spanclass="math inline">\(f(3)=6\)</span></td><td><span class="math inline">\(f[2,3]=\frac{6-9}{3-2}=-3\)</span></td><td><spanclass="math inline">\(f[1,2.3]=\frac{-3-4}{3-1}=-\frac{7}{2}\)</span></td></tr></tbody></table><h2 id="牛顿插值多项式构造">牛顿插值多项式构造</h2><ul><li>利用<em>均差表</em>的数据进行构造</li><li>用到了均差表对角线上的几个数 $ p(x)=f(1)+f[1,2] (x-1)+f<ahref="x-1">1,2,3</a>(x-2) \ p(x)=5+ 4(x-1)+-(x-1)(x-2) $</li></ul><h2 id="数值导数">数值导数</h2><h3 id="数值导数基本问题">数值导数基本问题</h3><ul><li><p>通过<strong>可微</strong>函数<spanclass="math inline">\(y=f(x)\)</span>在某点处的<em>函数值</em>如<spanclass="math inline">\(f(x_0),f(x_1),f(x_2)\)</span>,近似计算在某点的导数值<spanclass="math inline">\(f&#39;(x_1)\)</span></p></li><li><p>通过已知点的函数值，构造插值多项式<spanclass="math inline">\(P(x)\)</span>,用<spanclass="math inline">\(p&#39;(x1)\)</span>近似<spanclass="math inline">\(f&#39;(x1)\)</span></p></li></ul><p><img src="https://bu.dusays.com/2024/08/19/66c334ef25f31.jpg" /></p><h2 id="数值积分公式的构造">数值积分公式的构造</h2><h3 id="数值积分公式的形象">数值积分公式的形象</h3><p><span class="math inline">\(\int_{a}^{b} f(x) d x \approx\sum_{k=0}^{n} A_{k} f\left(x_{k}\right)\\\)</span></p><ul><li>根据数值积分公式，可以通过求特定点函数值，乘上特定系数，再进行组合的方式求得积分</li><li>注意符号使用的是约等于，但并不等于任何情况下都不等于原函数，有些情况下约等于会变成严格等于</li></ul><p><span class="math inline">\(\text { 例如: } \int_{a}^{b} f(x) d x\approx(b-a) f\left(\frac{a+b}{2}\right)\)</span> 称为中矩形公式</p><p><span class="math inline">\(\int_{a}^{b} f(x) d x \approx\frac{(b-a)}{2} f(a)+\frac{(b-a)}{2} f(b)\)</span> 称为梯形公式</p><h3 id="代数精度">代数精度</h3><p>如果某个求积公式对于次数不超过m的多项式均能准确成立，但对于m+1次多项式就不能准确成立，则称该求积公式具有<strong>m次</strong>代数精度。 *对于中矩形公式，当$f(x)=1,f(x)=x$时，左右两边严格相等，即中矩形公式代数精度为1</p><h3 id="用待定系数法构造数值积分公式">用待定系数法构造数值积分公式</h3><p>确定 <span class="math inline">\(\int_{0}^{1} f(x) d x \approx A_{0}f(0)+A_{1} f\left(\frac{1}{2}\right)+A_{2} f(1)\)</span>的求积系数，使其代数精度尽可能高</p><p><img src="https://bu.dusays.com/2024/08/24/66c9b195e6826.jpg" /> ##矩阵的直接三角分解法解线性方程组</p><h3 id="矩阵的直接三角分解">矩阵的直接三角分解</h3><p><span class="math display">\[ A=LU\]</span></p><p>其中，A为方阵，L为单位下三角阵，U为上三角阵。 *注意L为单位下三角阵，即对角线都为一 * U对角线下方都为0，对角线不变 <spanclass="math inline">\(L=\left[\begin{array}{cccc}1 &amp; 0 &amp; \cdots &amp; 0 \\I_{21} &amp; 1 &amp; \ddots &amp; 0 \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\I_{n 1} &amp; I_{n 2} &amp; \cdots &amp; 1\end{array}\right], \quad U=\left[\begin{array}{cccc}u_{11} &amp; u_{12} &amp; \cdots &amp; u_{1 n} \\0 &amp; u_{22} &amp; \ddots &amp; u_{2 n} \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\0 &amp; 0 &amp; \cdots &amp; u_{n n}\end{array}\right] \\\)</span></p><ul><li>将矩阵${} $进行直接三角分解</li></ul><p><span class="math inline">\(A=\left[\begin{array}{ccc}2 &amp; 1 &amp; 3 \\4 &amp; 4 &amp; 9 \\6 &amp; 5 &amp; 19\end{array}\right] \rightarrow\left[\begin{array}{ccc}2 &amp; 1 &amp; 3 \\2 &amp; 4 &amp; 9 \\3 &amp; 5 &amp; 19\end{array}\right] \rightarrow\left[\begin{array}{lll}2 &amp; 1 &amp; 3 \\2 &amp; 2 &amp; 3 \\3 &amp; 1 &amp; 19\end{array}\right] \rightarrow\left[\begin{array}{lll}2 &amp; 1 &amp; 3 \\2 &amp; 2 &amp; 3 \\3 &amp; 1 &amp; 7\end{array}\right]\)</span> <imgsrc="https://bu.dusays.com/2024/08/25/66ca7f4f316c6.jpg" /> ###利用直接三角分解解方程组</p><p>如果线性方程组<spanclass="math inline">\(Ax=b\)</span>的系数矩阵可以三角分解，则问题转化为<span class="math display">\[LUx=b\]</span></p><p>通过解两轮简单线性方程组 ,<span class="math inline">\(Ly=b\)</span>,<span class="math inline">\(Ux=y\)</span>即可求得解。</p><p>例：求解<span class="math inline">\(\left[\begin{array}{ccc}2 &amp; 1 &amp; 3 \\4 &amp; 4 &amp; 9 \\6 &amp; 5 &amp; 19\end{array}\right]\left(\begin{array}{l}x_{1} \\x_{2} \\x_{3}\end{array}\right)=\left(\begin{array}{l}3 \\8 \\11\end{array}\right)\\\)</span></p><p><img src="https://bu.dusays.com/2024/08/25/66ca81850dbd2.jpg" /></p>]]></content>
    
    
    
    <tags>
      
      <tag>计算方法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>考研7-31</title>
    <link href="/2024/07/31/%E8%80%83%E7%A0%947-31/"/>
    <url>/2024/07/31/%E8%80%83%E7%A0%947-31/</url>
    
    <content type="html"><![CDATA[<h1 id="英语">英语</h1><ul><li>睡前学新单词容易犯困，效率不高修改为早上一个半小时复习+新单词随身听一小时上午，下午空闲时间完成新单词学习 睡前复习当天所学单词</li><li>最近背单词的速度有所提升</li></ul><h1 id="数学">数学</h1><p>敲公式还是太麻烦了，以后只会记录重要知识点听课时一定要记笔记，稳扎稳打 公式插件更换为katex</p><h1 id="专业课">专业课</h1><h1 id="总结">总结</h1><ul><li>战线拖太长确实不好，所以现在应该更注重基础知识，为以后的复习铺路</li></ul><p>学习侧重：单词&gt;数学&gt;专业课</p><ul><li><p>不应该花过多的时间在写博客上，不能本末倒置。文章两天，三天一更。</p></li><li><p>今天换了新耳机！ 支持主动降噪和双设备连接，体验很不错 <imgsrc="https://bu.dusays.com/2024/07/31/66a9a2958bc25.webp"alt="Wingcloud X5s pro" /></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>考研</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>考研7.29</title>
    <link href="/2024/07/28/%E8%80%83%E7%A0%947-29/"/>
    <url>/2024/07/28/%E8%80%83%E7%A0%947-29/</url>
    
    <content type="html"><![CDATA[<h1 id="数学">数学</h1><p>记几道有意思的题</p><ul><li>函数定义域为 (0, <span class="math inline">\(+\infty\)</span> ) ，有<span class="math inline">\(2f(x)+x^{2} f(\frac{1}{x} ) = \frac{x^{2}+2x}{\sqrt{1+x^{2} } }\)</span> ，求 <spanclass="math inline">\(f(x)\)</span>这是一道考研数学的经典题，用复合函数和等式关系推导<spanclass="math inline">\(f(x)\)</span>具体思路是对原式进行倒带换，然后于原式消元求解</li></ul><p><span class="math display">\[\left\{\begin{aligned}2f(x)+x^{2} f(\frac{1}{x} ) = \frac{x^{2}+2x }{\sqrt{1+x^{2} } } \\2f(\frac{1}{x})+x^{2} f(x ) = \frac{1+2x}{x\sqrt{1+x^{2} } }\end{aligned}\right.\]</span></p><p>消元：一式*2-2式* <span class="math inline">\(x^{2}\)</span> 得 <spanclass="math inline">\(f(x)=\frac{x}{\sqrt{1+x^{2}}}\)</span></p><p>还有一些同类型题目，可以通过<strong>负</strong>代换求解</p><h1 id="算法">算法</h1><p>摸了一道DFS <ahref="https://www.luogu.com.cn/problem/P1036">p1036</a> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">p1036</span> &#123;<span class="hljs-comment">//20247.29</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> num[];<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> ans;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">Scanner</span> <span class="hljs-variable">scan</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><span class="hljs-type">int</span> n=scan.nextInt();<br><span class="hljs-type">int</span> k=scan.nextInt();<br>num=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>ans=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;n; i++) &#123;<br>num[i]=scan.nextInt();<br>&#125;<br>dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, k,<span class="hljs-number">0</span>);<br>System.out.println(ans);<br>scan.close();<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> s,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> st)</span> &#123;<br><span class="hljs-keyword">if</span> (x==k) &#123;<br><span class="hljs-type">int</span> flag=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;s/<span class="hljs-number">2</span>; i++) &#123;<br><span class="hljs-keyword">if</span> (s%i==<span class="hljs-number">0</span>) &#123;<br>flag=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">if</span> (flag==<span class="hljs-number">0</span>) &#123;<br>ans++;<br>&#125;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> st; j &lt; num.length; j++) &#123;<br>s+=num[j];x++;<br>dfs(s, x, k,j+<span class="hljs-number">1</span>);<br>s-=num[j];x--;<br>&#125;<br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>我是JAVA仙人</p><h1 id="英语">英语</h1><p>早上起来复习了昨天背的单词，有几个词还是需要重点记忆</p><ul><li>em.brace 拥抱，欣然接受</li><li>em.bryo 胚胎</li><li>ven.ti.late 使……通风，公开表达</li><li>thor.ough 全面的，彻底的</li></ul><p>睡前还是背40个单词</p><h1 id="总结">总结</h1><ul><li>今天更换了博客的渲染器，支持LeTeX公式~折腾了挺长时间，以后尽量不加新功能了 test: <figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>f(\cot^&#123;<span class="hljs-number">-1</span>&#125; )=\iiint_&#123;主&#125;^&#123;主&#125; int \<span class="hljs-keyword">sum</span> 主<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br><br></code></pre></td></tr></table></figure></li></ul><p>报错LaTeX-incompatible input and strict mode is set to 'warn':Unicode text characte r "主" used in math mode[unicodeTextInMathMode]难绷</p><p><span class="math display">\[E=mc^2\]</span></p><ul><li>今天的学习效率未到到预期，看来只有模糊的学习计划确实不行，必须要指定详细的时刻表</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>考研</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新的篇章--准备考研</title>
    <link href="/2024/07/28/%E6%96%B0%E7%9A%84%E7%AF%87%E7%AB%A0-%E5%87%86%E5%A4%87%E8%80%83%E7%A0%94/"/>
    <url>/2024/07/28/%E6%96%B0%E7%9A%84%E7%AF%87%E7%AB%A0-%E5%87%86%E5%A4%87%E8%80%83%E7%A0%94/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>自从五月份最后一次更新博客后，已经摆了接近两个月了。期间虽有写一些博文，但最终都没有推送过去。这两个月被学校折腾的死去回来，又是应付期末考试，又是被迫参加意义不明的金工实习，又被学校和某些学生气的七窍生烟。终于挨到了暑假，放纵了十来天之后，突然觉得再不行动就完蛋了</p><h1 id="选择考研的理由">选择考研的理由</h1><p>首先，是时候回答本科阶段的终极问题了：<strong>就业还是考研</strong>？刚入学时，我的目标很明确--梭哈JAVA，月入15K!但现在这个梦想已经无限接近于一个笑话了，经过我这几年的耳濡目染以及最近收集到的信息，计算机行业市场早已饱和，就业环境明显供过于求，且整个行业有<strong>精英化</strong>趋势。对学历的要求已经到了一个相当变态的程度，我一个吉林省的破二本若是去求职，最大的可能是找到一个月薪四五千的非技术岗位，吃两年福报然后被迫下海黄袍加身（<del>没有看不起外卖小哥的意思</del>）所以，在地区和学历的双重debuff之下，选择考研是我的无奈之举<del>希望学校不要再给我整花活了</del>近期我会去积极的获取信息，制定考研目标，规划方向，所以也有了这篇文章</p><h1 id="个人情况">个人情况</h1><p>目前在吉林市的一所二本就读，暂时没有挂科记录，学校知名度不高，专业人数极少，教学质量参差不齐，就考研来说毫无优势，大一，大二期间有积极参加学科竞赛。战绩有工训赛的国银，机创赛的省二，B组蓝桥杯JAVA省二。四级大一裸考470，六级至今没过，高中阶段数学，英语，政治都不是强项（<del>真是天崩开局啊</del>）</p><h1 id="考研方向">考研方向</h1><h2 id="科目">科目</h2><p>计算机一般有两个考试方向，自命题和408。许多学校的自命题相比11408会轻松很多，但是一旦落榜就很难调剂，且复试难度较大，而且好多这种学校貌似歧视双非，如大车埋土。总体风险太高，难度不低。408虽然复习难度更大，但是院校选择很多，网上资料也丰富，总体容错率高，所以我还是选择11408，也因此会早做准备。</p><h2 id="志愿">志愿</h2><p>个人倾向于考去南方的计算机一本强校或211，原因有三：杭州，南京，重庆等地区IT产业较为发达，就业情况好；北方某些院校有一些不能说的通病；最后，喜欢南方的发达地区。想去，杭州，重庆，深圳玩。</p><h1 id="学习策略">学习策略</h1><h2 id="政治">政治</h2><p>政治课没怎么听过，对该科目了解最少，目前计划有先听<ahref="https://space.bilibili.com/41832729?spm_id_from=333.337.0.0">陆寓丰</a>的课&gt; <strong>更新于 2024-12-31</strong><br />&gt;2025考研政治考前押题全部翻车，或许应该延长政治科目的复习时间，但毕竟政治有时效性，并非当务之急</p><h2 id="英语">英语</h2><p>本人词汇量极低，语法也是依托。目前在用APP“不背单词”，在近期也打算找一些外刊读&gt; <strong>更新于 2024-12-31</strong><br />经过半年的坚持，词汇量他提高了不少，假期每天至少分配一个小时背单词。但今年12月份六级发挥不是很好。我分析了如下几点原因：*做题技巧不够高明，应该多多训练，总结自己的方法，尤其是总结几套自己的作文模板* 考场上容易紧张，本来应该认识的词也不认识了 * 翻译能力欠缺 *阅读能力，速读能力不强，现在有了单词基础，应该大量阅读训练提取主干，快速定位，理解语境等能力## 数学（82高数+34线代+34概率）数学是学习重点，我打算先跟张宇老师<del>的盗版课</del>，后期会买一些习题册做，如660。姜晓千也是一位不错的老师，如果某个知识点学不懂会去看</p><p><ahref="https://www.youtube.com/playlist?list=PLkqMHcP63alkH174-O8dxZPaRqbvSrNIf">这里有资源</a>&gt; <strong>更新于 2024-12-31</strong><br />已入2026张宇基础30讲，有了这半年的基础，前期进度应该会很快。坚持先做，后听，并思考总结。不能一味赶进度，基础阶段慢就是块## 专业课专业课也是学习重点，包含四门（<del>妈的</del>）计算机组成原理（45），计算机网络（25），计算机操作系统（35），数据结构（45）最近打算先跟y总的数据结构课，同时学些计组如果有机会的话，蓝桥杯还想再打一把，这回用C++ &gt; <strong>更新于2024-12-31</strong><br />已经报名了明年的蓝桥杯，校赛成绩不错，老师给予厚望[汗]，假期以y总的课为主体，结合各路大佬的思路继续学习.注意，算法模板很重要！算法模板很重要！！算法模板很重要！！！近期还打算学习Diango入门软件开发，还有学习计组。# 最后 文章会不断更新，有什么感想和计划都会记录在此。 &gt;The lightwhich puts out our eyes is darkness to us. Only that day dawns to whichwe are awake. There is more day to dawn. The sun is but a morningstar.</p>]]></content>
    
    
    
    <tags>
      
      <tag>考研</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图(Map)的表示和图的搜索</title>
    <link href="/2024/05/18/Graph-DFS/"/>
    <url>/2024/05/18/Graph-DFS/</url>
    
    <content type="html"><![CDATA[<h1 id="图的表示">图的表示</h1><ul><li>一般习惯使用邻接表存图 <imgsrc="https://img1.baidu.com/it/u=931184270,2145738058&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=510&amp;h=358"alt="图的邻接表存储" /></li><li>使用ArrayList来写邻接表</li><li>假设需要表示一个有<strong>n</strong>个节点的图，先创建一个大小为n+1的ArrayList对象数组，然后遍历数组的节点，创建Arraylist对象</li><li>添加节点时，使用add方法直接加入，如添加u☞向v的节点graph[u].add(v)注意无向图<strong>两个方向都要存储</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">   List&lt;Integer&gt;[] graph=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>[n+<span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n+<span class="hljs-number">1</span>; i++) &#123;<br>graph[i]=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>u=scan.nextInt();<br>v=scan.nextInt();<br>graph[u].add(v);<span class="hljs-comment">//无向图存储两次</span><br>graph[v].add(u);<br>&#125;<br></code></pre></td></tr></table></figure> # 图的DFS<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> start)</span> &#123;<span class="hljs-comment">//参数：起始点，删除点，哈希标记集合</span><br><span class="hljs-keyword">if</span>(出口条件) &#123;<br><span class="hljs-comment">//Do Some Thing</span><br><span class="hljs-keyword">return</span>;<span class="hljs-comment">//递归出口</span><br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j:graph[start]) &#123;<br><span class="hljs-keyword">if</span>(set.contains(j)||<span class="hljs-comment">/*some condition*/</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//该节点已经走过||剪枝条件</span><br>set.add(j);<br>dfs(j, i);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure> <ahref="https://www.luogu.com.cn/problem/P8604">连通地道危险系数_DFS</a> #克鲁斯卡尔 # 迪杰斯特拉</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库基础</title>
    <link href="/2024/05/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/05/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="mysql的安装和配置">MySQL的安装和配置</h1><ul><li><p>尽量不要下载最新版，安装时可能没有开发者版本 <ahref="https://downloads.mysql.com/archives/installer/">官方安装链接</a></p></li><li><p>安装后配置MySQL的root用户密码，我的密码是<strong>123456</strong><em>若安装时忘记root密码，可在安装程序中删除注册表，再重新安装配置</em></p></li><li><p>添加环境变量，要写成Mysql<em>若不知道MySQl装在哪里，可以Win+R输入services.msc，在服务中找到MySQL,右键找到根目录</em></p></li><li><p>启动MySQL 一般开机自启，也可以在cmd输入net start/stop mysql80<em>使用管理员模式启动cmd</em></p></li><li><p>连接数据库 mysql -u root -p # 关系数据库基础 ## 基本定义</p></li><li><p>域：一组具有<strong>相同数据类型</strong>的值的<strong>集合</strong>，如整数，实数，性别</p></li><li><p>笛卡儿积：所有域的<strong>所有取值</strong>的组合 D1{a，b}D2{c,d} D1*D2={(a,c),(a,d),(b,c),(b,d)}</p></li><li><p>元组：<strong>笛卡儿积中每一个元素</strong>称作一个元组(Tuple),如(a,c)</p></li><li><p>分量：元组中每一个值称作一个分量</p></li><li><p>基数：笛卡尔积中的元素数量，如例中基数为2*2=4 ### 关系</p></li><li><p>关系的表示</p></li></ul><table><thead><tr><th>属性1</th><th style="text-align: center;">属性2</th><th>属性3</th></tr></thead><tbody><tr><td>1</td><td style="text-align: center;">a</td><td>b</td></tr><tr><td>2</td><td style="text-align: center;">c</td><td>d</td></tr><tr><td>3</td><td style="text-align: center;">e</td><td>f</td></tr></tbody></table><ul><li>表的每行对应一个<strong>元组</strong>，表的每列对应一个<strong>属性</strong>属性的取值范围叫做<strong>域</strong></li><li>n目/度关系必须有n个属性 ### 码</li><li>候选码：关系中某一属性的值能<strong>唯一</strong>地标识一个元组，称为候选码，<strong>可以有一个或多个</strong></li><li>全码：极端情况下，关系中<strong>所有属性</strong>都为这个关系的<strong>候选码</strong>，称为全码</li><li><strong>主码</strong>：若一个关系有多个候选码，则选定其中一个为<strong>主码</strong>，<strong>主码只有一个！</strong></li><li>主属性：候选码的诸属性</li><li>非主属性 ### 三类关系</li><li>基本关系(基本表) 实际存在的表</li><li>查询表 查询结果的表</li><li>视图表 导出的表，是虚表 ## 关系模式 <em>是对关系的描述</em> ###定义关系模式 形式：R(U,D,DOM,F) R:关系名U:组成关系的<strong>属性名</strong>的集合D:属性U中属性来自的<strong>域</strong>DOM:属性向域的<strong>映像</strong>集合F:属性间数据<strong>依赖</strong>关系</li><li>关系模式和关系：关系模式是<strong>静态</strong>的，稳定的，关系是<strong>动态</strong>的，随时间不断变化的</li><li>关系可以看作关系模式在某一时刻的状态或内容</li></ul><h1 id="基本关系操作">基本关系操作</h1><p><img src="https://bu.dusays.com/2024/05/08/663b4a16a2d31.png" /> *注意，<strong>基本</strong>关系运算只有五种：并（U）、差、（—）笛卡尔积（X）、投影、选择* 其它运算即交、连接和除，均可通过5种基本的运算来表达 ## 关系完整性 *<strong>实体完整性</strong>：若属性A是基本关系R的主属性，则属性A不能取空值<del>教材上没有</del>补充：不能取空，也<strong>不能相同</strong>，也不能随意<strong>更改</strong>*<strong>参照完整性</strong>：若属性或属性组F是基本关系R的外码它与基本关系S的主码Ks相对应，则对于R中每个元组在F上的值必须为<strong>空值</strong>（F的每个属性值<strong>均为空值</strong>）或<strong>等于S中某个元组的主码值</strong>* <strong>用户自定义完整性</strong> *<strong>外码</strong>：外码：设F是基本关系R的一个或一组属性，但不是关系R的码。如果F与基本关系S的主码Ks相对应，则称F是基本关系R的外码基本关系R称为<strong>参照关系</strong>基本关系S称为<strong>被参照关系</strong> * 关系R和S不一定是不同关系 *S和K必须定义在同一个域上 * 外码<strong>不一定</strong>要与对应主码同名## 专门的关系运算 /p10 *<strong>选择</strong>：在关系R中选择满足条件的诸元组<strong>选出行</strong><strong>σf(r)</strong>={t|t∈R∩F(t)='true'} 其中，f为选择条件,R为目标表如σSage&lt;20（Student）查询学生表（Student）中年龄（Sage）小于20的学生的所有信息（元组）*<strong>投影</strong>：从关系R中选出若干属性列组成新关系<strong>选出列</strong><strong>πA(R)</strong>={T[A]|t∈R} 其中，A为R的属性列，R为目标表如πSnane,Sdepet(Student)查询学生的姓名和所在系可以去重，显示不重复的分量 *<strong>连接</strong>：从两个关系的笛卡儿积中选取属性将间满足一定关系的元组<img src="https://bu.dusays.com/2024/06/02/665bf0d4f3713.png" />其中A和B分别为R和S上度数相等且可比的属性组 连接的结果是满足条件的属性组主要分为两种：</p><table><thead><tr><th>A</th><th style="text-align: center;">B</th><th>C</th></tr></thead><tbody><tr><td>a1</td><td style="text-align: center;">b1</td><td>5</td></tr><tr><td>a1</td><td style="text-align: center;">b2</td><td>6</td></tr><tr><td>a2</td><td style="text-align: center;">b3</td><td>8</td></tr><tr><td>a2</td><td style="text-align: center;">b4</td><td>12</td></tr></tbody></table><table><thead><tr><th>B</th><th style="text-align: center;">E</th></tr></thead><tbody><tr><td>b1</td><td style="text-align: center;">3</td></tr><tr><td>b2</td><td style="text-align: center;">7</td></tr><tr><td><strong>b3</strong></td><td style="text-align: center;">10</td></tr><tr><td><strong>b3</strong></td><td style="text-align: center;">2</td></tr><tr><td>b5</td><td style="text-align: center;">2</td></tr></tbody></table><p>1.等值链接R⊳⊲S A，B属性值相同 A=B | A | R.B | C | S.B | E ||----|:---:|---|-----|----| | a1 | b1 | 5 | b1 | 3 | | a1 | b2 | 6 | b2| 7 | | a2 | b3 | 8 | b3 | 10 | | a2 | b3 | 8 | b3 | 2 |</p><p>2.自然连接R⊳⊲S等值连接的特殊情况，A=B属性相同，<strong>很常用</strong>连接时去除重复属性</p><table><thead><tr><th>A</th><th style="text-align: center;">B</th><th>C</th><th>E</th></tr></thead><tbody><tr><td>a1</td><td style="text-align: center;">b1</td><td>5</td><td>3</td></tr><tr><td>a1</td><td style="text-align: center;">b2</td><td>6</td><td>7</td></tr><tr><td>a2</td><td style="text-align: center;">b3</td><td>8</td><td>10</td></tr><tr><td>a2</td><td style="text-align: center;">b3</td><td>8</td><td>2</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序</title>
    <link href="/2024/05/06/%E6%8E%92%E5%BA%8F/"/>
    <url>/2024/05/06/%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="排序">排序</h1><h2 id="数组排序">数组排序</h2><ul><li>Arrays.sort(int a[])对数组所有元素进行排序，默认升序</li><li>使<strong>用Lamda表达式</strong>修改排序</li><li><em>升序</em>：Arrays.sort(int a[]，(o1,o2)-&gt;o1-o2)</li><li><em>降序</em>：Arrays.sort(int a[]，(o1,o2)-&gt;o2-o1)</li><li><strong>对二维数组按第n个值排序</strong></li><li>Arrays.sort(nums,(o1,o2)-&gt;o1[n]-o2[n])可以应对复杂比较规则----------------------------------------</li><li>集合排序，使用与Arraylist，set等集合结构</li><li>Collections.sort(List&lt;&gt;arr)</li><li>集合排序也可以使用lamada表达式重写比较器 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">Scanner</span> <span class="hljs-variable">scan</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><span class="hljs-type">int</span>[] num=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;<span class="hljs-number">1</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">3</span>&#125;;<br><span class="hljs-type">int</span>[][] nums=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][] &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">9</span>&#125;,&#123;<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>&#125;,&#123;<span class="hljs-number">6</span>,<span class="hljs-number">9</span>,<span class="hljs-number">45</span>&#125;,&#123;<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">7</span>&#125;&#125;;<br>Arrays.sort(num);<br>Arrays.sort(nums,(o1,o2)-&gt;(o1[<span class="hljs-number">0</span>]-o2[<span class="hljs-number">0</span>])-(o1[<span class="hljs-number">2</span>]));<span class="hljs-comment">//可以这样重写</span><br><span class="hljs-comment">//Arrays.sort(nums);报错</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; num.length; i++) &#123;<br>System.out.print(num[i]+<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br>System.err.println(<span class="hljs-string">&quot;------num&quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; nums[i].length; j++) &#123;<br>System.out.println(nums[i][j]+<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br>System.out.println();<br>&#125;<br>scan.close();<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h2 id="快速排序分治">快速排序(分治)</h2><ul><li>1.确定分界点，可以取q[l],q[l+r/2]或q[r]随机</li><li>2.<strong>调整区间</strong>，小于等于x的数在区间左边，大于等于x的数在区间右边</li><li><h2 id="递归处理左右两端">3.递归处理左右两端</h2></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<span class="hljs-comment">//区间大小为0</span><br><br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l + r &gt;&gt; <span class="hljs-number">1</span>];<span class="hljs-comment">//选定x为分界点</span><br>    <span class="hljs-keyword">while</span> (i &lt; j)<span class="hljs-comment">//i在j左边，重复此过程</span><br>    &#123;<br>        <span class="hljs-keyword">do</span> i ++ ; <span class="hljs-keyword">while</span> (q[i] &lt; x);<span class="hljs-comment">//i在区间左端，若当前所指向数小于x,则向右移</span><br>        <span class="hljs-keyword">do</span> j -- ; <span class="hljs-keyword">while</span> (q[j] &gt; x);<span class="hljs-comment">//j在区间右端，若当前所指向数大于x,则向左移</span><br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(q, l, j), <span class="hljs-built_in">quick_sort</span>(q, j + <span class="hljs-number">1</span>, r);<span class="hljs-comment">//递归处理左右两端</span><br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java算法</tag>
      
      <tag>基础算法，c++算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8086总线操作</title>
    <link href="/2024/04/28/8086%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <url>/2024/04/28/8086%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="引脚及芯片功能">引脚及芯片功能</h2><p><img src="https://bu.dusays.com/2024/04/29/662f6e90b963f.png"alt="64003b86e138edc411c36cf3b2e40d6e.png" />以下功能遵循图片顺序介绍，自上至下，从左至右 * 8284A晶振，时钟信号发生器 * CLK 时钟信号，控制总线周期 * RESET 冷启动引脚 *ALE 地址锁存允许信号 * A19-A16 地址，状态复用引脚 * AD15-AD0地址，数据复用信号 * CPU 由 Intel于1978年 开发的 <strong>16</strong>位微处理器 * DEN'数据允许信号，控制数据收发器，低电平有效，详见数据收发器 * M/IO'存储器输入/IO控制信号，<strong>高</strong>电平表示CPU和存储器进行数据传输，<strong>低</strong>电平表示CPU和IO端口进行数据传输* WR' 写信号，低电平有效，具体写到哪里由M/IO'决定 * RD'读信号，低电平有效，具体读到哪里由M/IO'决定 * INTR 中断请求 *INTA'中断应答 * 8286地址锁存器，STB高电平IN,OUT直通，低电平地址信息<strong>锁存</strong>，不被IN改变* 数据收发器 小型设备可省略，AD可直连到内存储器，OE'是使能段 *内存储器，存储规则为十六位段基址(CS代码段,DS数据段,ES附加段,SS堆栈段)+四位偏移值(<strong>常以16进制给出</strong>)如：DS=0703H,偏移值[0003],内存地址物理表示为：07033H（5位16进制，<strong>总共20位2进制</strong>） * CS'是否使用内存储器 *IO接口芯片 连接外部设备(键盘，屏幕等)</p><figure><img src="https://bu.dusays.com/2024/04/29/662f781787abd.png"alt="1d2309aa163c40e2a770d8b43e5a8626.png" /><figcaptionaria-hidden="true">1d2309aa163c40e2a770d8b43e5a8626.png</figcaption></figure><h2 id="总线周期">总线周期</h2><p><img src="https://bu.dusays.com/2024/04/29/662f6e874db48.png"alt="20210412120620260.png" /> * T1周期 将地址通过AD，A传入地址锁存器 *T2周期 地址发送结束，AD发送数据 * T3周期 cpu发送信号将数据写入内存储器 *T4周期 空挡，信号复原</p>]]></content>
    
    
    <categories>
      
      <category>大学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编</tag>
      
      <tag>微机原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前缀和</title>
    <link href="/2024/04/27/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    <url>/2024/04/27/%E5%89%8D%E7%BC%80%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="前缀和">前缀和</h1><h2 id="算法原理">算法原理</h2><p>在程序设计中,可能会有查询一个长度为x的数组的相连m位的和的需求 *每次查询时间复杂度为m，若查询n次，时间复杂度就为n<em>m，<strong>0复杂度太高</strong></em> 这时可以使用前缀和思想优化算法 *前缀和仅需一次时间复杂度为On的预处理，后续查询时间复杂度为O1 *本质是把每次运算结果记录在前缀和数组中，<strong>以空间换时间</strong> *前缀和数组数很大，开long！开long！！开long！！！ <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> class 一维数组前缀和 &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">Scanner</span> <span class="hljs-variable">scan</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><span class="hljs-type">int</span> num[]=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>&#125;;<span class="hljs-comment">//目标数组</span><br><span class="hljs-type">int</span> sum[]=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">11</span>];<span class="hljs-comment">//前缀和（差分数组）开long，切记，切记！这里不开了嫌麻烦</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>sum[i+<span class="hljs-number">1</span>]=num[i]+sum[i];<br>&#125;<br>System.err.println(sum[<span class="hljs-number">10</span>]);<br>System.err.println(sum[<span class="hljs-number">10</span>]-sum[<span class="hljs-number">8</span>]);<span class="hljs-comment">//以On的时间复杂度计算了10+9</span><br><span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;num.length; i++) &#123;<br>ans+=num[i];<br>&#125;<br>System.out.println(ans);<br>scan.close();<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure> ##算法应用 <ahref="https://www.luogu.com.cn/problem/P1115">p1115最大子段和</a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">p1115</span>最大子段和 &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">Scanner</span> <span class="hljs-variable">scan</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><span class="hljs-type">int</span> n=scan.nextInt();<br><span class="hljs-type">int</span> ans=Integer.MIN_VALUE;<span class="hljs-comment">//返回值是最大字段和,初始化为integer最小值</span><br><span class="hljs-type">int</span> sum_num[]=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;=n; i++) &#123;<span class="hljs-comment">//初步思路，前缀和+dp</span><br>sum_num[i]=sum_num[i-<span class="hljs-number">1</span>]+scan.nextInt();<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;n+<span class="hljs-number">1</span>; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i-<span class="hljs-number">1</span>; j&gt;=<span class="hljs-number">0</span>; j--) &#123;<span class="hljs-comment">//不能将0计入</span><br><span class="hljs-type">int</span> sum=sum_num[i]-sum_num[j];<br>ans=Math.max(sum, ans);<br>&#125;<br>&#125;<br>System.out.println(ans);<br>scan.close();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure> * 该程序通过40%数据，仍需调优 *<del>坐牢的时候</del>想到了一个降低一半时间复杂的的优化方法：可以一边读入一边计算ans## 妈的，寄！ 还是过40 ### 改变思路 想到使用线性DP状态表示：DP[i]表示以第i位结尾时，最大子段和值状态转移方程：DP[i]=MAX(DP[i-1]+a[i],a[i])转移为 加上下一个数<strong>或</strong> 抛弃前面的数字以下一个数为首位计算子段 取最大，太过简单不再赘述 滚动数组优化：DP=MAX(DP+a[i],a[i])优化空间复杂度，别忘了记录最大值 <strong>经过计算不会爆int</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">Scanner</span> <span class="hljs-variable">scan</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><span class="hljs-type">int</span> dp=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> ans=Integer.MIN_VALUE;<br><span class="hljs-type">int</span> n=scan.nextInt();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br><span class="hljs-type">int</span> a=scan.nextInt();<br>dp=Math.max(dp+a, a);<br>ans=Math.max(ans, dp);<br>&#125;<br>System.out.println(ans);<br>scan.close();<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure> <strong>AC</strong>!不愧是我。<imgsrc="https://emotion.acs.pw/emotion/tieba_new/80.png" alt="芜湖" /></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Stack</title>
    <link href="/2024/04/25/Stack/"/>
    <url>/2024/04/25/Stack/</url>
    
    <content type="html"><![CDATA[<h1 id="栈stack">栈Stack</h1><p>栈的特点：后进后先</p><p><img src="https://bu.dusays.com/2024/04/25/662a1aebcf2dd.jpeg"alt="44a4fc21bceebb16ef03f40dfd737cb2.jpeg" /> * 初始化Stack<Integer>stack=new Stack&lt;&gt;(); * 栈的特点：先进后出 * Object push(Objectobj)压栈：压入栈顶/或add效果相同 * Object pop()弹栈：移除栈顶 * Objectpeek()查看栈顶，但不弹栈 * booleanisEmpty()返回：栈是否为空，<em>用法如</em> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(!stack.isEmpty)&#123;<br>   <span class="hljs-keyword">do</span> some thing<br>   &#125;<br></code></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">Scanner</span> <span class="hljs-variable">scan</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>Stack&lt;Integer&gt; stack=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>scan.close();<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>Java算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2024/04/21/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2024/04/21/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="并查集">并查集</h1><h2 id="算法适用">算法适用</h2><p>给定一些操作，查找联通块/查找集合数/查找环的个数 ## 节点初始化创建一维数组，大小为n+1，数组索引代表节点名，数组值代表指向节点 ##查找父节点 若当前节点指向自身，为根节点，找到并返回否则，顺着指向的节点（数组索引位置的值）继续寻找 ## 链接节点，合并集合<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a_value=find(a);<br><span class="hljs-type">int</span> b_value=find(b);<br>num[a_value]=b_value;<br></code></pre></td></tr></table></figure> 若根节点相同，可以不连接同时，若根节点相同，说明图中出现了环 ## 路径压缩 本质是存储搜索的结果<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> &#123;<br><span class="hljs-keyword">if</span> (num[a]==a) <span class="hljs-keyword">return</span> a;<br><span class="hljs-keyword">else</span> &#123;<br>num[a]=find(num[a]);<span class="hljs-comment">//路径压缩</span><br><span class="hljs-keyword">return</span> num[a];<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure> ## 返回集合个数指向自身的节点为一个集合的父节点，统计数组值等于自身的节点个数 ##应用实例 经典并查集题目<ahref="https://www.lanqiao.cn/problems/110/learning/?page=1&amp;first_category_id=1&amp;problem_id=110">合根植物</a>一道搜索题，也可以用并查集来解<ahref="https://www.luogu.com.cn/problem/P1451">细胞数量</a>使用面向对象的形式封装好 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> class 手搓并查集 &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">bcj</span>&#123;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> num[];<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">bcj</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<span class="hljs-comment">//参数是并查集的大小</span><br><span class="hljs-comment">// TODO 自动生成的构造函数存根</span><br> num=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br> <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;=n; i++) &#123;<br>num[i]=i;<span class="hljs-comment">//初始化 所有的节点祖先指向自身</span><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> &#123;<br><span class="hljs-keyword">if</span> (num[a]==a) <span class="hljs-keyword">return</span> a;<br><span class="hljs-keyword">else</span> &#123;<br>num[a]=find(num[a]);<span class="hljs-comment">//路径压缩,find函数的参数一定要填数组的值，一层一层找上去，否则无限循环</span><br><span class="hljs-keyword">return</span> num[a];<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> &#123;<span class="hljs-comment">//链接节点</span><br><span class="hljs-type">int</span> a_value=find(a);<br><span class="hljs-type">int</span> b_value=find(b);<br>num[a_value]=b_value;<span class="hljs-comment">//次序不重要</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumnode</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; num.length; i++) &#123;<br><span class="hljs-keyword">if</span>(num[i]==i) ans++;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>Scanner scan=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>bcj a=<span class="hljs-keyword">new</span> <span class="hljs-title class_">bcj</span>(scan.nextInt()*scan.nextInt());<br><span class="hljs-type">int</span> N=scan.nextInt();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>a.add(scan.nextInt(), scan.nextInt());<br>&#125;<br>System.out.println(a.sumnode());<br>scan.close();<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java算法</tag>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dosbox基础指令</title>
    <link href="/2024/04/19/dosbox%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4/"/>
    <url>/2024/04/19/dosbox%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h3 id="初始化">初始化</h3><p>将 e: 虚拟为DOSBOX仿真环境的C盘 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mount c e:\tc20<br></code></pre></td></tr></table></figure> 进入C盘（即 e: ）<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">c:</span><br></code></pre></td></tr></table></figure> <imgsrc="https://bu.dusays.com/2024/04/19/662291d0be24f.png"alt="20210204222449925.png" /> 仿真执行DOS系统的各种操作 ####进入调试模式 <figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">debug</span><br></code></pre></td></tr></table></figure> #### 写入指令 <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><br></code></pre></td></tr></table></figure></p><h4 id="查看寄存器内容">查看寄存器内容</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">r</span><br></code></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/04/19/662291d0bf380.png"alt="20210204223027116.png" /> #### 查看内存内容 <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">d</span><br></code></pre></td></tr></table></figure> <imgsrc="https://bu.dusays.com/2024/04/19/662291d0c8c3a.png"alt="20210204223301277.png" /> #### 查看指令栈(将机器指令翻译成汇编指令)<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">u</span><br></code></pre></td></tr></table></figure> <imgsrc="https://bu.dusays.com/2024/04/19/662291d0bedbf.png"alt="20210204223934420.png" /> #### 执行（ip指向位置）指令 <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">t</span><br></code></pre></td></tr></table></figure><img src="https://bu.dusays.com/2024/04/19/662291d0db966.png"alt="20210204224055955.png" /> #### 顺序运行到程序结束 <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><br></code></pre></td></tr></table></figure>#### 退出 <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">q</span><br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>大学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编</tag>
      
      <tag>dosbox</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DFS</title>
    <link href="/2024/04/18/dfs/"/>
    <url>/2024/04/18/dfs/</url>
    
    <content type="html"><![CDATA[<h1 id="dfs深度优先搜索与剪枝模板">dfs深度优先搜索与剪枝模板</h1><h2 id="为什么要用dfs">为什么要用dfs</h2><ul><li>提起dfs，最先会想到树和图的dfs，但算法中的dfs泛指一种<strong>暴力搜索</strong>的方式,即按照深度优先的次序来查找所有数据组合中符合需求的情况</li><li>与bfs（bfs先挖个坑）相比，dfs书写简单，容易理解<del>只要你够闲的话多写亿个for循环也能搞出来</del>，但容易<strong>爆栈</strong>，在使用时不要忘记观察数据范围，dfs大概率是过不了10的4次方以上的数据的</li><li><h2id="这里以洛谷p1025数的划分来举例讲解dfs">这里以洛谷p1025数的划分来举例讲解dfs</h2><h1 id="noip2001-提高组-数的划分">[NOIP2001 提高组] 数的划分</h1></li></ul><h2 id="题目描述">题目描述</h2><p>将整数 <span class="math inline">\(n\)</span> 分成 <spanclass="math inline">\(k\)</span>份，且每份不能为空，任意两个方案不相同（不考虑顺序）。</p><p>例如：<span class="math inline">\(n=7\)</span>，<spanclass="math inline">\(k=3\)</span>，下面三种分法被认为是相同的。</p><p><span class="math inline">\(1,1,5\)</span>;<br /><span class="math inline">\(1,5,1\)</span>;<br /><span class="math inline">\(5,1,1\)</span>.</p><p>问有多少种不同的分法。</p><h2 id="输入格式">输入格式</h2><p><span class="math inline">\(n,k\)</span> （<spanclass="math inline">\(6&lt;n \le 200\)</span>，<spanclass="math inline">\(2  \le k  \le  6\)</span>）</p><h2 id="输出格式">输出格式</h2><p><span class="math inline">\(1\)</span> 个整数，即不同的分法。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">7 </span><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><h2 id="提示">提示</h2><p>四种分法为：<br /><span class="math inline">\(1,1,5\)</span>;<br /><span class="math inline">\(1,2,4\)</span>;<br /><span class="math inline">\(1,3,3\)</span>;<br /><span class="math inline">\(2,2,3\)</span>.</p><p><strong>【题目来源】</strong></p><p>NOIP 2001 提高组第二题</p><hr /><ul><li><p>这是一道经典的dfs搜索题，首先来尝试暴力写法</p></li><li><p>输出为一个整数，定义ans变量记录分法</p></li><li><p>首先看题目的条件，分成k个数，我们定义count变量，当count==k时，这种情况符合题意，同时，这k个数的总和要=n，我们定义sum变量，当count==k且sum==n时，ans++;</p></li><li><p>为了保证所有情况不重复，循环时要令<strong>后面的数大于等于前面的数</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> suml,countl;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> n,k,ans=<span class="hljs-number">0</span>;<span class="hljs-comment">//整数n,分成k份，有ans种方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>Scanner scan=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>n=scan.nextInt();<br>k=scan.nextInt();<br>dfs(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>System.out.println(ans);<br>scan.close();<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> start ,<span class="hljs-type">int</span> sum,<span class="hljs-type">int</span> count)</span> &#123;<span class="hljs-comment">//参数：去重起始位，总和，数字个数</span><br><span class="hljs-keyword">if</span>(count==k) &#123;<span class="hljs-comment">//如果数字个数达到k，判断后一定要返回，不然无限循环</span><br><span class="hljs-keyword">if</span>(sum==n) &#123;<span class="hljs-comment">//如果相加等于n,ans+1</span><br>ans++;<br>&#125;<br><span class="hljs-keyword">return</span>;<span class="hljs-comment">//一定要有递归出口！！！！递归出口一定要写对位置！！！不然就是个爆栈！！！</span><br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i&lt;=n; i++) &#123;<span class="hljs-comment">//去重，保证后一个数一定大于等于前一个数</span><br>suml=sum+i;countl=count+<span class="hljs-number">1</span>;<br>dfs(i,suml,countl);<br>suml=sum-i;countl=count-<span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure> | | | | | | | | ## 剪枝</p></li><li><p>很显然，这种写法时间复杂度过高，无法通过所有测试用例,我们需要在for循环处做一些剪枝操作，不可能符合条件的值就不进入递归步骤</p></li><li><p>在写dfs时，习惯将判断条件放在最上面，剪枝等操作在进入递归前进行（for循环只是为了优化代码，不必要可以不写），递归前后要进行状态标记和状态回退</p></li><li><p>我们知道，枚举时后面的数一定大于等于前面的数，显然，当前的数i应符合这样的条件：sum+i*(k-count)&lt;=n</p></li><li><p>以下是优化过的代码 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">p1025</span>数的划分dfs剪枝 &#123;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> n,k,ans=<span class="hljs-number">0</span>;<span class="hljs-comment">//整数n,分成k份，有ans种方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>Scanner scan=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>n=scan.nextInt();<br>k=scan.nextInt();<br>dfs(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>System.out.println(ans);<br>scan.close();<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> start ,<span class="hljs-type">int</span> sum,<span class="hljs-type">int</span> count)</span> &#123;<span class="hljs-comment">//参数：去重起始位，总和，数字个数</span><br><span class="hljs-keyword">if</span>(count==k) &#123;<span class="hljs-comment">//如果数字个数达到k，判断后一定要返回，不然无限循环</span><br><span class="hljs-keyword">if</span>(sum==n) &#123;<span class="hljs-comment">//如果相加等于n,ans+1</span><br>ans++;<br>&#125;<br><span class="hljs-keyword">return</span>;<span class="hljs-comment">//一定要有递归出口！！！！递归出口一定要写对位置！！！不然就是个爆栈！！！</span><br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; sum+i*(k-count)&lt;=n; i++) &#123;<span class="hljs-comment">//去重，保证后一个数一定大于等于前一个数+减枝</span><br>dfs(i,sum+i,count+<span class="hljs-number">1</span>);<span class="hljs-comment">//可以这样写，也完成了状态标记和回退操作</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java算法</tag>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串String和StringBuilder</title>
    <link href="/2024/04/17/%E5%AD%97%E7%AC%A6%E4%B8%B2String%E5%92%8CStringBuilder/"/>
    <url>/2024/04/17/%E5%AD%97%E7%AC%A6%E4%B8%B2String%E5%92%8CStringBuilder/</url>
    
    <content type="html"><![CDATA[<h1 id="字符串类型和stringbuilder类">字符串类型和stringbuilder类</h1><h2 id="字符串类">字符串类</h2><h3id="string类即字符串java中所有字符串皆为该类对象">String类，即字符串，java中所有字符串皆为该类对象</h3><ul><li>String类固定用final修饰，<em>创建后不可更改</em>！！而字符串缓冲区（StringBuffer）支持可变字符串</li><li>！！由于String类对象都为final所以可被共享，即通过new申请内存空间后，只要字符序列（顺序和大小写）相同，无论再程序不同位置出现几次，jvm都<strong>只会建立一个String对象</strong>创建空字符串：String snull=new String(); 参数为字符串的构造方法：Stringstr=new String("value"); ### String类常用方法</li><li>char charAt(int index)返回索引位置字符</li><li>int length()返回字符串长度（<em>字符个数</em>）</li><li>intindexOf(string)返回指定子字符串<strong>第一次</strong>出现位置,<em>不存在返回-1</em></li><li>String concat（Stringstr）将str连接到字符串<strong>结尾</strong></li><li>int compareTo(Objectobj）<strong>重要！！以字典序进行比较，大于返回1，等于返回0，小于返回-1</strong></li><li>char[]toCharArray()转化为字符串数组，便于操作，<strong>常用</strong> --- ##StringBuilder字符串构造器</li><li>常用构造方法为无参构造：StringBuilder sb=new StringBuilder()</li><li>char charAt(int index)返回索引位置字符</li><li>int indexOf(string)返回指定子字符串第一次出现位置,不存在返回-1</li><li><strong>重点</strong>reveserse!!---StringBuilderreverse()<strong>返回顺序反转的StringBuilder对象</strong></li><li>boolen isEmpty()判断字符串是否为空</li><li>void append(Object obj)在末尾添加字符串</li><li>insert(int index, String x)在索引位置<strong>前面</strong>添加字符<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">Scanner</span> <span class="hljs-variable">scan</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>String snull=<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>();<span class="hljs-comment">//创建空字符串</span><br>String str=<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;value&quot;</span>);<br>System.err.println(str.charAt(<span class="hljs-number">0</span>));<br>System.err.println(str.indexOf(<span class="hljs-string">&quot;al&quot;</span>));<br>str.toCharArray();<br>StringBuilder sb=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>sb.append(<span class="hljs-string">&quot;wc&quot;</span>);<br>sb.insert(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;NB&quot;</span>);<span class="hljs-comment">//添加到索引位置前面</span><br>System.out.println(sb.reverse());<br>scan.close();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>Java算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速幂</title>
    <link href="/2024/04/16/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    <url>/2024/04/16/%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    
    <content type="html"><![CDATA[<h1 id="快速幂算法">快速幂算法</h1><ul><li>利用对幂次做<strong>加法分解</strong>，再相乘,得到o(long(n))的求幂算法</li><li>快速幂算法，输入参数为a^n</li><li><strong>返回值ans初始化为1</strong></li><li>while n不为0</li><li>（if）若每次循环n转化为<strong>二进制形式末尾为1</strong></li><li>ans*=a</li><li><strong>每次循环</strong></li><li>a*=a</li><li>二进制n后<strong>右</strong>移一位,即除2 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> class 快速幂算法 &#123;<br> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">qmi</span><span class="hljs-params">(<span class="hljs-type">long</span> a,<span class="hljs-type">long</span> b)</span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(b&gt;<span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-keyword">if</span>((b&amp;<span class="hljs-number">1</span>)&gt;<span class="hljs-number">0</span>)&#123;<br>        res = (res*a);<br>      &#125;<br>      a = (a*a);<br>      b&gt;&gt;=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-comment">/*利用对幂次做加法分解，再相乘,得到o(long(n))的求幂算法*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ksm</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> n)</span> &#123;<span class="hljs-comment">//快速幂算法，参数表示a^n</span><br><span class="hljs-type">int</span> ans=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(n&gt;<span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> ((n&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//若此时的n转化为二进制后末尾为1</span><br>ans*=a;<span class="hljs-comment">//数据过大时，可在此处取模</span><br>&#125;<br>a*=a;<span class="hljs-comment">//数据过大时，可在此处取模</span><br>n&gt;&gt;=<span class="hljs-number">1</span>;<span class="hljs-comment">//转化为二进制后右移一位</span><br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>Scanner in=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><span class="hljs-type">int</span> a=in.nextInt();<span class="hljs-type">int</span> b=in.nextInt();<br>System.out.println(ksm(a, b));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java算法</tag>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>set集合</title>
    <link href="/2024/04/15/set%E9%9B%86%E5%90%88/"/>
    <url>/2024/04/15/set%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h1 id="hashset类常用方法">hashset类常用方法</h1><ul><li>add(Objectobj)<strong>向集合中添加元素</strong>，添加成返回true，失败（集合中已有该元素）返回false</li><li>size()<strong>返回集合中元素个数</strong></li><li>remove（Objectobj）<strong>删除set集合元素</strong>，成功返回true，失败返回false</li><li>contains(Objectobj)<strong>查询集合中的元素</strong>，若set包含元素，返回true，否则返回false</li><li>clear()<strong>清除集合中所有元素</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashSet;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">import</span> java.util.Set;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">___set</span>集合 &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>Scanner scan= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><span class="hljs-type">boolean</span> flag=<span class="hljs-literal">false</span>;<br>Set&lt;Integer&gt; hset=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>flag=hset.add(<span class="hljs-number">1</span>);<br>System.out.println(flag);<span class="hljs-comment">//add成功，返回true</span><br>flag=hset.add(<span class="hljs-number">1</span>);<br>System.out.println(flag);<span class="hljs-comment">//add失败，返回false</span><br>scan.close();<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>Java算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分法</title>
    <link href="/2024/04/15/%E4%BA%8C%E5%88%86/"/>
    <url>/2024/04/15/%E4%BA%8C%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="二分法">二分法</h1><h2 id="二分搜索算法">二分搜索算法</h2><ul><li>用于在有序集合中查找元素，时间复杂度为ologN</li><li>二分具有二段性：给定条件可以将集合中元素分为两部分，一部分满足条件，一部分不满足条件---- # 步骤</li><li>首先将（有序）集合分成两段，<strong>左边段</strong>[left,n-1]<strong>右边段</strong>[n,right]</li><li>若mid落在左半段（&lt;n）left=mid</li><li>若mid落在右半段（&gt;=n）right=mid</li><li>然后else中left向右移动（加1），right向左移动（减1）</li><li>若出现left=mid,计算mid要向上取整（加1）</li><li>勤加练习，必能掌握 ### java实现 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> arr[]=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;<br><span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> left1=<span class="hljs-number">0</span>,right1=<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> k=<span class="hljs-number">3</span>;<span class="hljs-comment">//要查找的值</span><br><span class="hljs-keyword">while</span>(left&lt;right) &#123;<span class="hljs-comment">//查找上界</span><br><span class="hljs-type">int</span> mid=(left+right)&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(arr[mid]&gt;=k) &#123;<span class="hljs-comment">//界限可变</span><br>right=mid;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>left=mid+<span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">while</span>(left1&lt;right1) &#123;<span class="hljs-comment">//查找下界</span><br><span class="hljs-type">int</span> mid=(left1+right1+<span class="hljs-number">1</span>)&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(arr[mid]&lt;k) &#123;<br>left1=mid;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>right1=mid-<span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>System.out.println(left+<span class="hljs-string">&quot; &quot;</span>+left1);<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java算法</tag>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/04/14/hello-world/"/>
    <url>/2024/04/14/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="创建新文章">创建新文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>详情: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="启动本地服务器">启动本地服务器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>详情: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="生成静态文件">生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>详情: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="远程服务器部署">远程服务器部署</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>详情: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a><img src="https://bu.dusays.com/2024/04/15/661d185a37e59.jpg"alt="v2-cadb722c283c20b1a24f56581995d1f9_r.jpg" /></p>]]></content>
    
    
    
    <tags>
      
      <tag>博客入门</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
